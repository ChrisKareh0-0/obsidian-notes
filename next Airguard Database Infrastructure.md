---
date: 2025-07-20 21:59:56
category: topic
tags:
  - status/new
  - Airguard
  - Convex
  - postgres
  - MLflow
---
[[Airguard channel compliance]]
[[Airguard - AI - Stack - Explained]]

The strategic blueprint for your AI-driven network management system incorporates a sophisticated and multi-layered database infrastructure, meticulously designed to handle heterogeneous data types, support real-time edge operations, and power complex cloud-based AI. This infrastructure adheres to best practices in database design, ensuring scalability, resilience, and data integrity across the entire platform.

### Database Infrastructure: A Comprehensive Design

#### 1. Determine the Purpose

The overarching goal of the database infrastructure is to enable an autonomous, AI-driven network management system by efficiently storing, processing, and making accessible all relevant data. This includes facilitating real-time anomaly detection, supporting global AI model training and improvement, providing long-term memory for central AI reasoning, auditing edge AI decisions, managing network device inventory and configurations, streamlining MLOps workflows, enabling GitOps for declarative management, and ensuring robust disaster recovery.

#### 2. Gather and Organise Requirements

The system collects and processes a diverse range of information, necessitating different storage solutions:

- **Edge-Generated Data (Local & Uplinked)**:
    - **Raw Spectral Data (Local)**: Fast Fourier Transform (FFT) spectral data directly from the `ath11k` wireless driver via `debugfs` interface. Stored locally on the Jetson's NVMe drive as a "flight recorder" for full-fidelity forensic replay and offline retraining. Formatted in binary for raw samples, with JSON for metadata.
    - **Processed Spectral Data (Uplinked)**: Lightweight Convolutional Autoencoder (CAE) feature vectors (256B) for real-time anomaly detection and global model training. Transmitted with LZ4 compression.
    - **Operational Metrics & Status (Uplinked)**: Frame capture rate, monitor mode status, monitor capture statistics, monitor channel dwell time, monitor injection capability, spectral FFT period, spectral scan priority, spectral noise-floor override, spectral short-report enable, DFS false-alarm rate, thermal status matrix, power consumption vector. Encoded in CBOR for efficiency.
    - **Coordination Matrices (Uplinked & Local)**: Inter-radio interference, channel assignment matrix, co-channel interference matrix, adjacent-channel leakage, intermodulation products, diversity combining metrics, for multi-radio coordination and Multi-Armed Bandit (MAB) algorithm input. Encoded in CBOR.
    - **Event Logs (Uplinked)**: Monitor mode transition logs, DFS event records, anomaly alerts, interference class records, decision log entries, crypto key rotation logs, access control events, compliance snapshots. Encoded in JSON for human readability and detailed context.
    - **Calibration & Reference Data (Uplinked)**: Reference noise floor, gain calibration matrix, TX power calibration delta, RX gain calibration matrix, frequency offset correction, antenna coupling matrix, environmental correction. Encoded in CBOR.
    - **LoRaWAN Backhaul Payloads (Uplinked)**: State vectors (128B), agent heartbeats (64B), critical alert summaries (32B), config acknowledgements (8B), for maintaining fleet visibility and minimal coordination during WAN outages. These are highly compressed, often using CBOR and LoRaWAN spreading factors.
    - **Location & Orientation Data**: GPS coordinates and Gyroscope/IMU data, correlated with RF and visual data.
    - **Visual Data**: Manually uploaded site photos, linked to the agent's data for multimodal analysis without continuous streaming. Stored as JPEG/PNG.
    - **Federated Learning Gradients**: Small, anonymised model updates (4KB) for global model improvement, avoiding raw data upload. Encoded in Protobuf.
    - **Firmware & Capabilities**: Firmware version, spectral scan capability flags, monitor-mode support matrix.
- **Cloud-Based Data**:
    - **Kubernetes Cluster State**: Deployment definitions, services, ConfigMaps, and other Kubernetes objects.
    - **Rancher Management Plane Configuration**: User definitions, permissions, downstream cluster connection information, application catalog settings.
    - **Application Persistent Data**: Stateful data generated by applications running on edge nodes, stored in Persistent Volumes (PVs).
    - **MLOps Metadata**: Experiment tracking (parameters, metrics), model artifacts, model versions, data versioning metadata.
    - **Network Inventory & Source of Truth**: Device details, configurations, and network topology data for managing a heterogeneous fleet.
    - **AI Model Outputs & Insights**: Natural language reports, configuration diffs, strategic recommendations.
    - **User/Customer Data**: For the "Founder's Program" and general service management.

#### 3. Divide Information into Tables (or Database Types)

Given the diverse data types and access patterns, the architecture employs multiple, specialised database solutions rather than a single monolithic database:

- **Core Kubernetes Cluster State**: Handled by **etcd** (embedded or external) within the K3s/RKE2 clusters for high availability and resilience of the control plane.
- **Edge Orchestration Metadata**: **SQLite** is used by KubeEdge EdgeCore on the Jetson devices for local, persistent metadata storage, enabling edge autonomy during disconnections. CloudCore synchronises with the central K3s etcd.
- **Distributed Block Storage (for Stateful Applications)**: **Longhorn** provides persistent, replicated storage for containerised applications across the Kubernetes cluster, supporting edge disaster recovery via remote S3 backups.
- **Raw Data Lake**: **Amazon S3** is the primary target for storing raw, high-volume data like sensor data and visual media uploaded from edge devices or collected via "data mule".
- **Structured Operational & Configuration Data**: **PostgreSQL** is the chosen relational database for managing structured data, including the backend for Convex, network inventory (e.g., NetBox data), and various logs and metadata. **Amazon Redshift** is also mentioned for structured data warehousing. These will include specific tables for:
    - Device inventory (`Asset-Inventory DB`).
    - Configuration snapshots (`Config-DB`).
    - Compliance records (`Compliance Svc` input).
    - User/customer data for the Founder's Program.
- **Vector Database (Long-Term Memory)**: **Milvus** or **Weaviate** (cloud-based) for storing historical vector embeddings of network states, enabling similarity searches and long-term AI reasoning. **FAISS** (Facebook AI Similarity Search) is considered for more lightweight, on-device (Jetson) local short-term memory.
- **Time-Series Monitoring Data**: **Prometheus** for aggregating and querying time-series metrics from edge agents (e.g., `monitor_mode_status`, `thermal_status_matrix`, `agent_heartbeat`). **Loki** is used for collecting and querying logs.
- **MLOps & Experiment Tracking**: **MLflow** for tracking experiments, managing models, and maintaining a model registry. **DVC (Data Version Control)** for versioning datasets, linking them to Git without storing large files. **Langfuse** is specified for anomaly alerts. **Kubeflow Drift Job** for calibration data.
- **Rancher Configuration**: Rancher's own configuration data is stored within the Kubernetes cluster it operates on, separate from the workload clusters.

#### 4. Turn Information Items into Columns

For each of these database types, specific data points map to columns or fields:

- **Vector Databases (Milvus/Weaviate/FAISS)**:
    - `embedding_vector`: The numerical representation of a network state.
    - `timestamp`: When the state was captured.
    - `device_id`: Unique identifier for the edge agent.
    - `gps_coordinates`: Latitude, longitude, altitude.
    - `imu_data`: Gyroscope and accelerometer readings.
    - `visual_data_ref`: Reference/link to associated site photos in S3.
    - `anomaly_type`: Type of anomaly detected (if any).
    - `interference_class`: Classification of interference (e.g., Microwave Oven, Bluetooth FHSS).
- 
- **PostgreSQL (Structured Data)**:
    
    - **`devices` table (Asset Inventory)**: `device_id` (PK), `vendor`, `product_os`, `primary_api`, `secondary_api`, `mcp_implementation_library`, `firmware_version`, `spectral_scan_capability_flags`, `monitor_mode_support_matrix`, `last_seen_timestamp`, `deployment_location`, `customer_id`.
    - **`configs` table**: `config_id` (PK), `device_id` (FK), `timestamp`, `config_data` (JSON/YAML), `change_source`, `applied_by`, `status`.
    - **`logs` table (General)**: `log_id` (PK), `device_id` (FK), `timestamp`, `log_level`, `message`, `details` (JSON).
    - **`decisions` table**: `decision_id` (PK), `device_id` (FK), `timestamp`, `decision_made` (e.g., channel change), `reasoning_summary`, `mab_reward`, `impact_metrics`.
    - **`calibration_data` table**: `calibration_id` (PK), `device_id` (FK), `timestamp`, `type` (e.g., noise_floor, gain), `values` (JSON/CBOR representation of matrices/deltas).
    - **`compliance_events` table**: `event_id` (PK), `device_id` (FK), `timestamp`, `event_type` (e.g., DFS radar, access control), `details` (JSON).
    - **`founder_program_users` table**: `user_id` (PK), `customer_name`, `email`, `is_founder` (boolean), `discount_level`, `data_contribution_consent`.
- **Prometheus (Time-Series)**:
    
    - `metric_name` (e.g., `frame_capture_rate`, `thermal_status_matrix_cpu_temp`)
    - `timestamp`
    - `device_id` (label)
    - `value` (numerical).
- **Loki (Logs)**:
    
    - `timestamp`
    - `device_id` (label)
    - `log_message` (text)
    - `stream` (e.g., `monitor_mode_transition_log`, `decision_log_entry`).
- **S3 (Object Storage)**:
    
    - `object_key` (unique path, e.g., `raw_fft/device_id/timestamp.bin`)
    - `content` (binary raw FFT, PNG spectrograms, JPEG/PNG images)
    - `metadata` (JSON file alongside binary/image, containing timestamp, device_id, GPS, IMU, etc.).
- **MLflow (Experiment Tracking)**:
    
    - `run_id` (PK)
    - `experiment_id` (FK)
    - `start_time`, `end_time`
    - `parameters` (JSON)
    - `metrics` (JSON, e.g., anomaly detection accuracy, MAB rewards)
    - `artifact_uri` (link to model files in S3).
- **DVC (Data Version Control)**:
    
    - `data_version_id` (PK)
    - `git_commit_hash` (FK)
    - `data_path` (reference to S3 location)
    - `md5_checksum`
    - `size_bytes`.

#### 5. Specify Primary Keys

Each identified table or data entity will have a primary key to ensure unique identification:

- **Relational Tables (PostgreSQL)**:
    - `device_id` (for `devices` table).
    - Composite keys like (`device_id`, `timestamp`) for time-series logs and configuration changes.
    - Auto-incrementing IDs (`log_id`, `decision_id`, `calibration_id`, `event_id`, `user_id`) for other tables.
- **Vector Databases**: `vector_id` (or implicitly `timestamp` + `device_id` as unique identifier).
- **Time-Series Databases (Prometheus/Loki)**: Time-series databases typically use a combination of metric name/label and timestamp as their effective key.
- **Object Storage (S3)**: The unique object key (path and filename) serves as the identifier.
- **MLflow/DVC**: `run_id` for MLflow, `data_version_id` for DVC, with strong links to Git commit hashes.

#### 6. Define Relationships Between Tables

The different database components are interconnected through logical relationships and data flow:

- **Edge-to-Cloud Data Flow**:
    - Edge agents publish processed data (CAE feature vectors, metrics, logs, events) via MQTT to various cloud ingestion targets.
    - The **KubeEdge EventBus** (an MQTT client) handles communication between the DeviceTwin and device mappers at the edge, ingesting sensor data via MQTT.
    - The `Vector-Gateway` processes CAE feature vectors before storing them in **Milvus**.
    - Monitoring metrics are pushed to **Prometheus**, logs to **Loki**, and specific alerts to **Langfuse** or compliance services.
    - Calibration and drift data feed into a **Kubeflow Drift Job**.
    - Firmware and inventory data populate the **Asset-Inventory DB**.
    - LoRaWAN data flows via a `Resilience Daemon` to `PagerDuty Bridge` or to `Peer MAB` / `Cloud Orchestrator`.
    - Federated Learning gradients are aggregated by a `Federated-Learner Pipeline`.
- **Cloud AI Interactions**:
    - The **Vision-Language Model (VLM)** in the cloud ingests feature vectors from the vector database (Milvus/Weaviate), GPS/IMU data, and site photos (from S3) for comprehensive network understanding.
    - The **Multi-LLM Router** directs user queries to appropriate LLMs (Llama 3, Phi-3 Vision).
    - LLM-generated configuration changes are validated by **Pydantic AI** against predefined schemas and sent as **MCP `tools/call` messages** via MQTT to the edge agents for secure execution.
    - The **Multi-Agent Reinforcement Learning (MARL)** system on AWS (SageMaker RL + RLlib) learns global optimisation policies based on network state data and feeds these policies back to edge agents.
- **MLOps Workflow**:
    - **DVC** tracks versions of datasets (stored in S3), linking them to **Git commits**.
    - **MLflow** tracks training runs, logs parameters/metrics, and registers model artifacts, with references to data versions.
    - **GitHub Actions** (CI/CD) orchestrates the training pipeline, pushing new model container images to a registry (e.g., Amazon ECR) and updating **GitOps repository** manifests.
    - **Argo CD** (GitOps controller) monitors the GitOps repository and automatically deploys updated models to the **KubeEdge**-managed Jetson fleet.
- **Source of Truth Integration**: **NetBox** acts as a central Source of Truth, which can be populated and queried by Ansible or Nornir scripts, integrating network inventory with automation workflows.
- **Multi-Cluster Management**: **Rancher** provides a unified interface to manage all downstream K3s/KubeEdge clusters, including their underlying datastores and persistent volumes.

#### 7. Refine the Design

The design is refined by adopting a hybrid edge-cloud architecture that leverages purpose-built databases for specific data characteristics. This ensures that:

- **Data Locality**: Time-critical processing and raw data buffering occur at the edge, reducing backhaul bandwidth.
- **Scalability**: Cloud-based services (AWS S3, PostgreSQL, Milvus, SageMaker) provide virtually unlimited storage and compute for global intelligence and long-term analysis.
- **Resilience**: KubeEdge's local metadata store enables edge autonomy, and the multi-layered disaster recovery strategy (K3s snapshots, Rancher backup operator, Longhorn PV backups to S3) protects all critical data.
- **Efficiency**: Using compact encoding formats like CBOR and Protobuf for uplinked edge data minimises bandwidth consumption.

#### 8. Apply Normalisation Rules

While a detailed, column-level normalisation is outside this high-level blueprint, the architectural choices inherently support normalisation principles:

- **Reduction of Redundancy**: By distributing data across specialised databases (e.g., raw data in S3, structured metadata in PostgreSQL, metrics in Prometheus), the system avoids storing the same information redundantly in inappropriate formats. For instance, spectral feature vectors are small and uploaded, while raw FFT is buffered locally and only retrieved on demand, preventing constant, high-volume redundancy in the cloud.
- **Data Integrity**: Using relational databases like PostgreSQL for structured data (e.g., device inventory, configuration) allows for the enforcement of referential integrity (via foreign keys) and data type constraints, ensuring consistency. The schema-based nature of Protocol Buffers also contributes to data consistency for inter-service communication.
- **Modularity and Independence**: Separating concerns into distinct database systems (e.g., monitoring data in Prometheus, MLOps data in MLflow) ensures that changes in one data domain do not directly impact others, promoting a more maintainable and scalable architecture. The use of specific data models like KubeEdge's Device CRDs for network devices also ensures a well-defined structure.

[[Summarize]]